## 배열(Array)


- **같은 자료형**의 변수들을 하나의 묶음으로 다루는 것

    다른 자료형을 보내고 싶으면 객체를 생성해야

- 배열은 저장된 값 마다 인덱스 번호가 부여됨. (0부터 시작)

    배열명 arr을 정하고 다음에 **방의 개수**를 무조건 정해야(초기화 시) - 방 개수 수정X

    `int[] arr = new int[5];`

    **같은 자료형의 타입**으로 만듦으로 **방의 크기**는 동일

    **방의 번호** → **인덱스 번호** (0~)

- 세로로 쓰던 변수들을 가로로 줄 지어서 묶은 것 = 배열

- 추가 필기

cf. 자바의 참조자료형 데이터 타입

참조자료형은 기본자료형과 달리 Stack에 직접 값을 할당하는 것이 아니고

- Stack - Heap의 주소를 참조
- Heap - 실제값을 올림

배열 변수는 힙 영역의 배열 객체를 참조

**참조자료형의 특징**

- new 키워드로 생성한 객체 → 배열도 객체에 속함
- String과 배열은 new 없이 객체를 생성할 수 없지만 참조자료형에 속함
- class, array, interface, enummeration을 참조자료형이라고 한다.

## 배열 저장구조


- Stack

    자료형의 이름은 Stack이라는 방에 저장됨 (변수의 이름을 넣을 수 있음)

    변수의 메소드명이 저장됨

- Heap

    실제 값은 Heap 영역에 저장됨. (new를 통해)

    new int[4]; 

    값을 가진 내용들은 똑같은 크기의 방 4개가 Heap에 저장됨(휘발성 - 메모리 공간에 올려두었다가 사라지는 것)

    선언된 상태이고 값을 넣어두진 않았음. - int[] arr

    new int[4]; 를 통해 int arr[]은 커다란 네모의 주소를 리턴값으로 받음. (그리고 인덱스로 찾아감)

    Heap에 방을 만들었을 때 그 메모리의 주소를 int[] arr에 보내줌

    Stack은 Heap의 주소값을 참조하고 있음.

    arr[0] 이라고 하면 Heap의 arr[0]의 주소값을 찾아옴.

    heap에는 값이 없는 상태로 못 들어감 없으면 초기값이라도 자동으로 넣어짐 (int 형 배열이면 0이 채워짐)

- Static

## 배열을 사용하는 이유

만약 배열을 사용하지 않는다면 변수를 여러 개 사용해야 한다

1. 연속된 메모리 공간으로 관리할 수 있다.(모든 변수의 이름을 사용자가 관리해야 한다)

2. 반복문을 이용한 연속 처리가 불가능하다.

cf. 헷갈리지 말기

String 클래스의 length는 `()`

`arr.length`는 ()가 없음.

## 배열의 선언

자료형[] 변수명; (변수명 = 배열명)

자료형 변수명[]; 

`int[] iarr;`

`char carr[];`

arr도 Heap에 만들어진 값을 Stack이 참조해서 쓰고 있는 것. 

like String이 참조형 변수인 것 처럼

배열도 Heap 영역에 방을 만들고 Stack이 참조해서 쓰는 것.

## 배열의 기본값

기본적으로 배열을 선언하고 할당하게 되면 

배열의 각 인덱스에는 `자바에서 지정한 기본값`으로 초기화가 된 상태가 된다. by JVM

이유 - heap 영역은 값이 없는 빈 공간이 존재할 수 없기 때문

## 다차원 배열

- 다차원 배열은 2차원 이상의 배열을 의미
- 배열의 인덱스마다 또 배열의 주소를 보관하는 배열을 의미

→ 즉, 2차원 배열은 1차원 배열 여러 개를 하나로 묶어서 관리하는 배열을 의미
